// Copyleft (C) 2022 Robin Syihab.
// All Rights Reserved.
//
// This code is part of Leak Checker.
//

// #![feature(generators, generator_trait, type_alias_impl_trait)]
#![feature(associated_type_defaults)]

extern crate clap;
#[macro_use]
extern crate lazy_static;

use byteorder::ByteOrder;
use byteorder::{LittleEndian, WriteBytesExt};
use lz_fnv::{Fnv1a, FnvHasher};
use std::{
    fs::File,
    io::{self, prelude::*, BufReader, Result, SeekFrom},
};


pub mod converter;
pub mod parsers;



/// Lhash file reader.
pub struct LhashReader {
    file: File,
    ready: bool,
}

impl LhashReader {
    pub fn new(filename: &str) -> Result<Self> {
        let file = File::open(filename)?;
        Ok(Self { file, ready: false })
    }

    pub fn read(&mut self) -> Result<u64> {
        if !self.ready {
            let mut reader = BufReader::new(&self.file);
            let mut buffer = String::new();
            reader.read_line(&mut buffer)?;
            if !buffer.starts_with("This file is lhash format generated by") {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidData,
                    "Invalid lhash file",
                ));
            }
            let mut buffer = String::new();
            reader.read_line(&mut buffer)?;
            reader.seek(SeekFrom::Current(1))?; // skipt 2nd newline
            self.ready = true;
        }
        self.read_next()
    }

    fn read_next(&mut self) -> Result<u64> {
        if !self.ready {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid lhash file",
            ));
        }
        let mut buffer = [0; 8];
        self.file.read_exact(&mut buffer)?;
        Ok(LittleEndian::read_u64(&buffer))
    }
}


#[inline(always)]
fn hash(input: &str) -> u64 {
    let mut hasher = Fnv1a::<u64>::new();
    hasher.write(input.as_bytes());
    hasher.finish()
}

#[inline(always)]
fn to_bytes(input: u64) -> [u8; 8] {
    let mut bytes = [0; 8];
    let mut writer = io::Cursor::new(&mut bytes[..]);
    writer.write_u64::<LittleEndian>(input).unwrap();
    bytes
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hash() {
        assert_eq!(hash("ABC123"), 15690175261855128325);
        assert_eq!(hash("3111892"), 0x0a56724cdbb65716);
    }

    #[test]
    fn test_file_format() {
        let mut reader = LhashReader::new("./tests/metranet.lhash").unwrap();
        assert_eq!(reader.read().unwrap(), 0xd20bc4eb5e59dfa0);
        assert_eq!(reader.read().unwrap(), 0xa25a625fcafd40c8);
        assert_eq!(reader.read().unwrap(), 0x6238eb19db67870f);
        assert_eq!(reader.read().unwrap(), 0xb6bd591c1688e715);
        assert_eq!(reader.read().unwrap(), 0xbc3e204f95b2113f);
        assert_eq!(reader.read().unwrap(), 0x39b1ff7fa764c6c1);
    }
}


