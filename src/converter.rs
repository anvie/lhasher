// Copyleft (C) 2022 Robin Syihab.
// All Rights Reserved.
//
// This code is part of Leak Checker.
//

use std::{
    collections::BTreeSet,
    fs::File,
    io::{prelude::*, BufReader, Result},
    path::Path,
};

use lhash::{hash, to_bytes};

use crate::{
    parsers::{ParseStatus::*, Parser, Tokens},
};

pub fn parse_file<PR, PT>(filename: PT, mut p: PR) -> Result<()>
where
    PR: Parser,
    PT: AsRef<Path>,
{
    let file = File::open(filename)?;
    let mut file_output = File::create(
        Path::new("../compiled_data")
            .join(p.file_out_name())
            .with_extension("lhash"),
    )?;

    file_output.write_all(
        format!(
            "This file is lhash format generated by https://github.com/anvie/lhasher\n\
{}\n\n",
            p.name()
        )
        .as_bytes(),
    )?;

    let reader = BufReader::new(file);

    let mut i = 0;
    let mut existing = BTreeSet::new();
    let mut buffer = vec![];
    let mut buffered_tokens: Option<Tokens> = None;

    for line in reader.lines() {
        let line = line?;
        match p.parse(&line)? {
            Buffer(part) => buffer.push(part),
            Ignored => {}
            BufferEnd(part) => {
                buffer.push(part);
                if let Ok(Ready(tokens)) = p.parse(&buffer.join("\n")) {
                    buffered_tokens = Some(tokens);
                }
                buffer.clear();
            }
            Ready(tokens) => {
                buffered_tokens = Some(tokens);
            }
        }

        if let Some(tokens) = buffered_tokens {
            for token in tokens {
                if token.is_empty() {
                    continue;
                }
                let a_hash = hash(&token);
                if existing.contains(&a_hash) {
                    continue;
                }

                existing.insert(a_hash);

                file_output.write(&to_bytes(a_hash))?;

                i = i + 1;
                if i % 10_000 == 0 {
                    println!("{} -> {} - exists: {}", token, a_hash, existing.len());
                    file_output.flush()?;
                }
            }
            buffered_tokens = None;
        }
    }
    file_output.flush()?;
    file_output.write_all(b"\"\"\n")?;
    file_output.write_all(b"]}\n")?;
    Ok(())
}
